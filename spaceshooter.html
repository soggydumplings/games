<meta name='viewport' content='width=device-width, initial-scale=1'/><!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Evil Space Balloons</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  background: black;
  overflow: hidden;
  touch-action: none;
}
canvas {
  display: block;
  background: #000;
}
#ui {
  position: fixed;
  bottom: 20px;
  width: 100%;
  padding: 0 20px;
  display: flex;
  justify-content: space-between;
  box-sizing: border-box;
}
#dpad {
  position: relative;
  width: 160px;
  height: 160px;
}
.arcade-btn {
  position: absolute;
  width: 56px;
  height: 56px;
  background: #888;
  border-radius: 15px;
  box-shadow: 0 8px 0 #444;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: transform 0.05s;
}
.arcade-btn.pressed {
  box-shadow: none;
  transform: translateY(8px);
}
.up { top: 0; left: 52px; }
.down { bottom: 0; left: 52px; }
.left { left: 0; top: 52px; }
.right { right: 0; top: 52px; }
.icon-up { 
  width: 0; height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 18px solid #222;
}
.icon-down {
  width: 0; height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-top: 18px solid #222;
}
.icon-left {
  width: 0; height: 0;
  border-top: 12px solid transparent;
  border-bottom: 12px solid transparent;
  border-right: 18px solid #222;
}
.icon-right {
  width: 0; height: 0;
  border-top: 12px solid transparent;
  border-bottom: 12px solid transparent;
  border-left: 18px solid #222;
}
#shoot {
  position: relative;
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background: #c33;
  box-shadow: 0 10px 0 #711;
  
  display: inline-block; 
  cursor: pointer;
  border: none;
  outline: none;
  -webkit-tap-highlight-color: transparent;
  
  
  transition: transform 0.05s; 
}

#shoot.pressed {
  box-shadow: none !important;
  transform: translateY(10px) !important; 
}


.controls-container {
  position: fixed;
  bottom: 30px;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between; 
  align-items: center;            
  padding: 0 40px;                
  pointer-events: none;     
}

#dpad, #shoot {
  pointer-events: auto;
}


</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
  <div class="controls-container">
  <div id="dpad">
    <div class="arcade-btn up"><div class="icon-up"></div></div>
    <div class="arcade-btn down"><div class="icon-down"></div></div>
    <div class="arcade-btn left"><div class="icon-left"></div></div>
    <div class="arcade-btn right"><div class="icon-right"></div></div>
  </div>
  
  <button id="shoot"></button>
</div>

    
</div>

<script>
/* ================= Canvas Setup ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

/* ================= Audio ================= */
const AudioCtx = new (window.AudioContext || window.webkitAudioContext)();

function startBGM() {
  const melody = [440, 494, 523, 587, 659, 698, 784, 523, 587, 659, 698, 784, 880, 784, 659];
  let i = 0;

  function playNote() {
    const now = AudioCtx.currentTime;
    const osc = AudioCtx.createOscillator();
    const gain = AudioCtx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(melody[i % melody.length], now);

    gain.gain.setValueAtTime(0.02, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);

    osc.connect(gain);
    gain.connect(AudioCtx.destination);

    osc.start(now);
    osc.stop(now + 0.18);

    i++;
    setTimeout(playNote, 200); // rhythm interval
  }

  playNote();
}

// Start BGM
startBGM();

function playEnemyFireSound() {
  const now = AudioCtx.currentTime;
  const osc = AudioCtx.createOscillator();
  const gain = AudioCtx.createGain();

  osc.type = 'triangle'; 
  osc.frequency.setValueAtTime(600, now);
  osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);

  gain.gain.setValueAtTime(0.1, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

  osc.connect(gain);
  gain.connect(AudioCtx.destination);

  osc.start(now);
  osc.stop(now + 0.15);
}

function playGunSound() {
  const now = AudioCtx.currentTime;
  const osc = AudioCtx.createOscillator();
  const gain = AudioCtx.createGain();

  osc.type = 'square'; 
  
  osc.frequency.setValueAtTime(1200, now);
  osc.frequency.exponentialRampToValueAtTime(400, now + 0.08);

  gain.gain.setValueAtTime(0.2, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);

  osc.connect(gain);
  gain.connect(AudioCtx.destination);

  osc.start(now);
  osc.stop(now + 0.08);
}

function playEnemyHitSound() {
  const now = AudioCtx.currentTime;

  // --- pop noise (bright & snappy) ---
  const bufferSize = AudioCtx.sampleRate * 0.05; // short and crisp
  const buffer = AudioCtx.createBuffer(1, bufferSize, AudioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    // bright, fast-decaying white noise
    data[i] = (Math.random() * 2 - 1) * Math.exp(-15 * i / bufferSize);
  }
  const noise = AudioCtx.createBufferSource();
  noise.buffer = buffer;
  const noiseGain = AudioCtx.createGain();
  noiseGain.gain.setValueAtTime(0.2, now);
  noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
  noise.connect(noiseGain);
  noiseGain.connect(AudioCtx.destination);
  noise.start(now);
  
  const osc = AudioCtx.createOscillator();
  const gain = AudioCtx.createGain();
  osc.type = "triangle";
  osc.frequency.setValueAtTime(800, now); // high-mid "snap"
  osc.frequency.exponentialRampToValueAtTime(1500, now + 0.03);
  gain.gain.setValueAtTime(0.08, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
  osc.connect(gain);
  gain.connect(AudioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.05);
}
function playExplosionSound(){
  const dur = 0.8;
  const bufSize = AudioCtx.sampleRate * dur;
  const buf = AudioCtx.createBuffer(1, bufSize, AudioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for(let i=0; i<bufSize; i++){
    const t = i / bufSize;
    data[i] = (Math.random()*2 - 1) * (1 - t) * Math.exp(-t * 5);
  }
  const src = AudioCtx.createBufferSource();
  src.buffer = buf;
  const filter = AudioCtx.createBiquadFilter();
  filter.type = "lowpass";
  filter.frequency.setValueAtTime(800, AudioCtx.currentTime);
  filter.frequency.exponentialRampToValueAtTime(60, AudioCtx.currentTime + dur);
  src.connect(filter).connect(AudioCtx.destination);
  src.start();
}

function playHpUpSound() {

  const ladderNotes = [1046.50, 1174.66, 1318.51, 1567.98, 2093.00]; 
  const noteGap = 0.05; // 50ms between notes

  ladderNotes.forEach((freq, index) => {
    const oscillator = AudioCtx.createOscillator();
    const gainNode = AudioCtx.createGain();

    oscillator.type = 'square'; // Keep it sharp and retro
    oscillator.frequency.setValueAtTime(freq, AudioCtx.currentTime + (index * noteGap));
    gainNode.gain.setValueAtTime(0.1, AudioCtx.currentTime + (index * noteGap));
    gainNode.gain.exponentialRampToValueAtTime(0.0001, AudioCtx.currentTime + (index * noteGap) + 0.1);

    oscillator.connect(gainNode);
    gainNode.connect(AudioCtx.destination);

    oscillator.start(AudioCtx.currentTime + (index * noteGap));
    oscillator.stop(AudioCtx.currentTime + (index * noteGap) + 0.12);
  });
}



/* ================= Game Objects ================= */
const ship = {x:0, y:0, width:24, height:20, shield:false};
const bullets = [];
const enemyBullets = [];
const keys = {};
let lives = 3;
let score = 0;
let wave = 1;
let gameOver = false;
let explosions = [];

const stars = [];
for(let i=0; i<150; i++){
  stars.push({
    x: Math.random()*canvas.width,
    y: Math.random()*canvas.height,
    size: Math.random()*2 + 1,
    speed: Math.random()*0.5 + 0.2
  });
}

function drawStars(){
  ctx.fillStyle = "#fff";
  stars.forEach(s=>{
    ctx.fillRect(s.x, s.y, s.size, s.size);
    s.y += s.speed;
    if(s.y > canvas.height) s.y = 0;
  });
}

/* ================= Enemies ================= */
let enemies = [];
let enemyBaseSpeed = 0.3;
let enemyBulletSpeed = 2; 
let enemyShootChance = 0.0001;
const maxEnemySpeed = 2;
const maxShootChance = 0.001;

function spawnWave(){
  enemies = [];
  const rows = Math.min(2 + Math.floor(wave/2), 10);
  const cols = Math.min(5 + wave, 10);
  const spacingX = canvas.width / (cols + 1);
  const spacingY = 50;
  for(let r=0; r<rows; r++){
    for(let c=0; c<cols; c++){
      enemies.push({
        baseX: spacingX*(c+1),
        x: spacingX*(c+1),
        y: -50 - r*spacingY,
        alive: true,
        speedY: enemyBaseSpeed,
        phase: Math.random()*Math.PI*2,
        amplitude: 20 + Math.random()*15,
        frequency: 0.02 + Math.random()*0.02
      });
    }
  }
}

/* ================= Explosions ================= */
function spawnExplosion(x, y, player=false){
  const count = player ? 60 : 16;
  for(let i=0; i<count; i++){
    explosions.push({
      x, y,
      vx: (Math.random()-0.5)*(player?10:5),
      vy: (Math.random()-0.5)*(player?10:5),
      life: player ? 60 : 30,
      color: player ? (Math.random()<0.5?"#f00":"#f90") : "#f33"
    });
  }
  player ? playExplosionSound() : playEnemyHitSound();
}

function drawExplosions(){
  for(let i = explosions.length-1; i>=0; i--){
    const p = explosions[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    ctx.globalAlpha = p.life / (p.color==="#f33"?30:60);
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, 4, 4);
    ctx.globalAlpha = 1;
    if(p.life <= 0) explosions.splice(i, 1);
  }
}

/* ===Items ===*/
let items = [];
let hpIconSpawnedThisWave = false;

function spawnHPIcon() {
  items.push({
    x: Math.random() * (canvas.width - 40) + 20,
    y: -50,
    speed: 1.5,
    angle: 0
  });
}

function drawItems() {
  for (let i = items.length - 1; i >= 0; i--) {
    const item = items[i];
    item.y += item.speed;
    item.angle += 0.05; // Rotation speed for the shield

    const x = item.x;
    const y = item.y;
    const size = 3; // Same scale as UI hearts

    // Draw Rotating Energy Shield
    ctx.save();
    ctx.translate(x + (size * 2.5), y + (size * 2));
    ctx.rotate(item.angle);
    ctx.strokeStyle = "#00FFFF";
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]); // Dotted/dashed look
    ctx.beginPath();
    ctx.arc(0, 0, 25, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

    drawHeart(x, y, size);

    ctx.fillStyle = "#fff";
    
    ctx.fillRect(x + (size * 1.5), y + (size * 2), size * 2, size / 1.5);
    
    ctx.fillRect(x + (size * 2.2), y + (size * 1.3), size / 1.5, size * 2);

    const dist = Math.hypot(ship.x - (x + 10), ship.y - (y + 10));
    if (dist < 30) {
      if (lives < 3) {
        lives++;
      } else {
        score += 3000;
      }
      items.splice(i, 1);
      playHpUpSound();
    }

    if (item.y > canvas.height) items.splice(i, 1);
  }
}

/* ================= Draw Objects ================= */
function drawShip() {

  const x = ship.x;
  const y = ship.y;
  
  const p = 35 / 15; 

// --- ENGINE FLAME ---
  const time = Date.now() * 0.01;
  
  for (let j = 0; j < 3; j++) {
    const flickerX = Math.sin(time + j) * 2;
    
    const flickerY = Math.random() * 10 + 8; 
    
    ctx.fillStyle = j === 0 ? "rgba(0, 255, 255, 0.4)" : "rgba(255, 255, 255, 0.3)";
    
    ctx.beginPath();
    ctx.moveTo(x - 3, y + 15); 
    ctx.quadraticCurveTo(
      x + flickerX, y + 15 + flickerY, 
      x + 4, y + 15
    );
    ctx.fill();
  }

  // 0=Empty, 1=White/Grey, 2=Red, 3=Blue
  const galagaMap = [
    [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0], 
    [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0], 
    [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
 
[0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],
    [0,0,0,2,0,0,1,1,1,0,0,2,0,0,0],
    [0,0,0,2,0,1,1,1,1,1,0,2,0,0,0], 
    [2,0,0,1,3,1,1,2,1,1,3,1,0,0,2], 
    [2,0,0,3,1,1,2,2,2,1,1,3,0,0,2], 
    [1,0,0,1,1,1,2,1,2,1,1,1,0,0,1], 
    [1,0,1,1,1,1,1,1,1,1,1,1,1,0,1], 
    [1,1,1,1,1,2,1,1,1,2,1,1,1,1,1], 
    [1,1,1,0,2,2,1,1,1,2,2,0,1,1,1], 
    [1,1,0,0,2,2,0,1,0,2,2,0,0,1,1], 
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
  ];

  const startX = x - (35 / 2); 
  const startY = y - ((16 * p) / 2); 

  galagaMap.forEach((row, rIdx) => {
    row.forEach((pixel, cIdx) => {
      if (pixel === 0) return;

      if (pixel === 1) ctx.fillStyle = "#FFFFFF"; 
      if (pixel === 2) ctx.fillStyle = "#FF0000"; // Red
      if (pixel === 3) ctx.fillStyle = "#557AFF"; // Blue

      ctx.fillRect(startX + (cIdx * p), startY + (rIdx * p), Math.ceil(p), Math.ceil(p));
    });
  });
//draw shield
  if (ship.shield) {
    const time = Date.now() * 0.005;
    const pulse = Math.sin(time) * 2;
    const radius = 28 + pulse;

    ctx.save();
    
    ctx.globalCompositeOperation = "screen"; 

    let grad = ctx.createRadialGradient(x, y, 5, x, y, radius);
    grad.addColorStop(0, "rgba(0, 255, 255, 0.1)");   // Very faint cyan over the ship
    grad.addColorStop(0.6, "rgba(0, 150, 255, 0.2)"); // Mid-depth blue
    grad.addColorStop(0.9, "rgba(255, 255, 255, 0.6)"); // Bright rim
    grad.addColorStop(1, "rgba(0, 200, 255, 0)");     // Outer fade

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = "rgba(200, 255, 255, 0.5)";
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.restore();
  }

}


function drawBullets() {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];

    // --- 1. MASSIVE FLAME EFFECT ---
    const time = Date.now() * 0.02;
    // Layered flickering flames
    for (let j = 0; j < 3; j++) {
      const flickerX = Math.sin(time + j) * 3;
      const flickerY = Math.random() * 20 + 15; // Big, long flames
      
      ctx.fillStyle = j === 0 ? "rgba(255, 150, 0, 0.6)" : "rgba(255, 50, 0, 0.4)";
      ctx.beginPath();
      ctx.moveTo(b.x - 1, b.y + 16);
      ctx.quadraticCurveTo(
        b.x + 1 + flickerX, b.y + 16 + flickerY, 
        b.x + 3, b.y + 16
      );
      ctx.fill();
    }

    // --- 2. SLEEK MISSILE BODY ---
    ctx.fillStyle = "#ff0000";
    ctx.beginPath();
    ctx.moveTo(b.x + 1, b.y);       // Sharp tip
    ctx.lineTo(b.x - 1, b.y + 7);   // Base left
    ctx.lineTo(b.x + 3, b.y + 7);   // Base right
    ctx.fill();

    ctx.fillStyle = "#ffffff";
    ctx.fillRect(b.x - 1, b.y + 7, 4, 12);

    // Darker Steel Fins
    ctx.fillStyle = "#444";
    ctx.fillRect(b.x - 3, b.y + 14, 2, 5); // Left fin
    ctx.fillRect(b.x + 3, b.y + 14, 2, 5); // Right fin

    // Movement
    b.y -= 8; 
    if (b.y < -40) {
      bullets.splice(i, 1);
    }
  }
}

function drawEnemies(){
  enemies.forEach(e=>{
    if(!e.alive) return;
    if(e.x === undefined || e.y === undefined) return; // safety check

    if(e.blinkCounter === undefined) e.blinkCounter = Math.floor(Math.random()*60);
    if(e.mouthSymbolCounter === undefined) e.mouthSymbolCounter = 0;
    
    if(!e.color){

const baseColors = [
  "#7DF9FF",
  "#0096FF",
  "#89CFF0",
  "#E1C16E",
  "#CD7F32",
  "#A52A2A",
  "#228B22",
  "#50C878",
  "#097969",
  "#FFBF00",
  "#FFAC1C",
  "#FF5F1F",
  "#FF4433",
  "#DC143C",
  "#DE3163",
  "#FF69B4",
  "#5D3FD3",
  "#BF40BF",
  "#7F00FF",
  "#EE4B2B",
  "#C41E3A",
  "#FF3131",
  "#FFD700",
  "#FFDB58",
  "#FFEA00",
  "#8B8000",
  "#FF0000",
  "#0000FF",
  "#00FF7F",
  "#00BFFF",
  "#00FF7F",
  "#FF69B4",
  "#FF6347"
];

      e.color = baseColors[Math.floor(Math.random()*baseColors.length)];
    }

    // ===== Balloon Body =====
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.ellipse(e.x, e.y, 18, 20, 0, 0, Math.PI*2);
    ctx.fill();

    // ===== Balloon Knot (Trapezium) =====
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.moveTo(e.x - 2, e.y + 19); // Top left
    ctx.lineTo(e.x + 2, e.y + 19); // Top right
    ctx.lineTo(e.x + 4, e.y + 23); // Bottom right
    ctx.lineTo(e.x - 4, e.y + 23); // Bottom left
    ctx.closePath();
    ctx.fill();

    // ===== Eyes =====
const eyeOffsetX = 6;
const eyeOffsetY = -4;

const goggleRadius = 5.5;
const goggleStroke = 3;

e.blinkCounter--;
const isBlinking = e.blinkCounter <= 0 && e.blinkCounter > -10;
if (e.blinkCounter <= -10) {
  e.blinkCounter = Math.floor(Math.random() * 200);
}

// Look direction
const dx = ship.x - e.x;
const dy = ship.y - e.y;
const angle = Math.atan2(dy, dx);
const pupilDist = 2;

// === Goggle strap ===
ctx.strokeStyle = "#555";
ctx.lineWidth = 5;
ctx.beginPath();
ctx.moveTo(e.x - 19.5, e.y + eyeOffsetY);
ctx.lineTo(e.x + 19.5, e.y + eyeOffsetY);
ctx.stroke();

// === Goggle rims ===
ctx.strokeStyle = "#bbb";
ctx.lineWidth = goggleStroke;

// Left rim
ctx.beginPath();
ctx.arc(
  e.x - eyeOffsetX,
  e.y + eyeOffsetY,
  goggleRadius,
  0,
  Math.PI * 2
);
ctx.stroke();

// Right rim
ctx.beginPath();
ctx.arc(
  e.x + eyeOffsetX,
  e.y + eyeOffsetY,
  goggleRadius,
  0,
  Math.PI * 2
);
ctx.stroke();

// === Eyeballs ===
ctx.fillStyle = "#fff";

// Left eye
ctx.beginPath();
ctx.arc(
  e.x - eyeOffsetX,
  e.y + eyeOffsetY,
  4,
  0,
  Math.PI * 2
);
ctx.fill();

// Right eye
ctx.beginPath();
ctx.arc(
  e.x + eyeOffsetX,
  e.y + eyeOffsetY,
  4,
  0,
  Math.PI * 2
);
ctx.fill();

// === Pupils / Blink ===
if (!isBlinking) {
  ctx.fillStyle = "#000";

  // Left pupil
  ctx.beginPath();
  ctx.arc(
    e.x - eyeOffsetX + Math.cos(angle) * pupilDist,
    e.y + eyeOffsetY + Math.sin(angle) * pupilDist,
    2,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Right pupil
  ctx.beginPath();
  ctx.arc(
    e.x + eyeOffsetX + Math.cos(angle) * pupilDist,
    e.y + eyeOffsetY + Math.sin(angle) * pupilDist,
    2,
    0,
    Math.PI * 2
  );
  ctx.fill();
} else {
  ctx.strokeStyle = "#000";
  ctx.lineWidth = 2;

  // Left blink
  ctx.beginPath();
  ctx.moveTo(e.x - eyeOffsetX - 3, e.y + eyeOffsetY);
  ctx.lineTo(e.x - eyeOffsetX + 3, e.y + eyeOffsetY);
  ctx.stroke();

  // Right blink
  ctx.beginPath();
  ctx.moveTo(e.x + eyeOffsetX - 3, e.y + eyeOffsetY);
  ctx.lineTo(e.x + eyeOffsetX + 3, e.y + eyeOffsetY);
  ctx.stroke();
}
        // ===== Wavy String =====
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    const startY = e.y + 23; // Connects to the bottom of the knot
    const stringLength = 20;
    const waveFrequency = 0.2; // How many bumps
    const waveAmplitude = 2;   // How wide the waves are
    const speed = Date.now() * 0.002;

    ctx.moveTo(e.x, startY);

    for (let i = 0; i <= stringLength; i++) {
      // Calculate the x-offset using a sine wave
      const xOffset = Math.sin(i * waveFrequency + speed) * waveAmplitude;
      ctx.lineTo(e.x + xOffset, startY + i);
    }
    
    ctx.stroke();
  });
}
function drawHeart(x, y, size) {
  // Draw black border (smaller)
  ctx.fillStyle = "#000";
  ctx.fillRect(x + size - 1, y - 1, size + 2, size + 2);
  ctx.fillRect(x + size * 3 - 1, y - 1, size + 2, size + 2);
  ctx.fillRect(x - 1, y + size - 1, size * 5 + 2, size * 2 + 2);
  ctx.fillRect(x + size - 1, y + size * 3 - 1, size * 3 + 2, size + 2);
  ctx.fillRect(x + size * 2 - 1, y + size * 4 - 1, size + 2, size + 2);

  // Draw red heart on top
  ctx.fillStyle = "#f00"; // red
  ctx.fillRect(x + size, y, size, size);
  ctx.fillRect(x + size * 3, y, size, size);
  ctx.fillRect(x, y + size, size * 5, size * 2);
  ctx.fillRect(x + size, y + size * 3, size * 3, size);
  ctx.fillRect(x + size * 2, y + size * 4, size, size);
}

function drawEnemyBullets() {
  const T = null;
  const R = "#ff2a00";
  const O = "#ff5a00";
  const Y = "#ffb300";
  const L = "#ffcc33";
  const W = "#ffe066";

  const sprite = [
    [T,T,T,R,T,T,T],
    [T,T,R,T,T,T,T],
    [T,R,R,T,T,T,T],
    [T,R,R,T,T,T,T],
    [T,R,R,T,R,T,T],
    [T,R,R,T,T,R,T],
    [T,R,R,T,R,R,T],
    [T,R,Y,R,R,R,T],
    [T,R,Y,R,Y,R,T],
    [T,R,Y,Y,Y,R,T],
    [R,R,Y,L,Y,R,T],
    [R,Y,L,W,Y,R,R],
    [R,Y,W,W,L,Y,R],
    [R,Y,W,W,W,Y,R],
    [R,Y,Y,W,Y,Y,R],
    [T,R,Y,Y,Y,R,T],
    [T,T,R,R,R,T,T],
  ];

  const px = 1;

  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    const b = enemyBullets[i];

    const x0 = b.x | 0;
    const y0 = b.y | 0;

    for (let y = 0; y < sprite.length; y++) {
      for (let x = 0; x < sprite[y].length; x++) {
        const c = sprite[y][x];
        if (c === T) continue;

        ctx.fillStyle = c;
        ctx.fillRect(
          x0 + x * px,
          y0 + y * px,
          px,
          px
        );
      }
    }

    b.y += b.speed;
    if (b.y > canvas.height + 30) {
      enemyBullets.splice(i, 1);
    }
  }
}

function drawUI() {
  const padding = 16;
  const heartSize = 3;

  ctx.font = "bold 18px 'Courier New', Courier, monospace";
  ctx.textBaseline = "top";
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#000";

  const labelColor = "#e0e0e0"; // bright grey
  const numberColor = "#ffff00";  // red

  // ===== LIVES (LEFT) =====
  ctx.textAlign = "left";
  ctx.fillStyle = labelColor;
  ctx.strokeText("LIVES", padding, 10);
  ctx.fillText("LIVES", padding, 10);

  for (let i = 0; i < lives; i++) {
    drawHeart(padding + i * (heartSize * 7), 36, heartSize);
  }

  // ===== WAVE (CENTER) =====
  ctx.textAlign = "left";
  const waveLabel = "WAVE:";
  const waveNumber = wave.toString();

  const waveTotalWidth =
    ctx.measureText(waveLabel).width +
    ctx.measureText(waveNumber).width;

  const waveX = canvas.width / 2 - waveTotalWidth / 2;

  ctx.fillStyle = labelColor;
  ctx.strokeText(waveLabel, waveX, 10);
  ctx.fillText(waveLabel, waveX, 10);

  ctx.fillStyle = numberColor;
  ctx.strokeText(
    waveNumber,
    waveX + ctx.measureText(waveLabel).width,
    10
  );
  ctx.fillText(
    waveNumber,
    waveX + ctx.measureText(waveLabel).width,
    10
  );

  // ===== SCORE (RIGHT) =====
  ctx.textAlign = "right";
  const scoreLabel = "SCORE:";
  const scoreNumber = score.toString();

  const scoreX = canvas.width - padding;

  ctx.fillStyle = labelColor;
  ctx.strokeText(
    scoreLabel,
    scoreX - ctx.measureText(scoreNumber).width,
    10
  );
  ctx.fillText(
    scoreLabel,
    scoreX - ctx.measureText(scoreNumber).width,
    10
  );

  ctx.fillStyle = numberColor;
  ctx.strokeText(scoreNumber, scoreX, 10);
  ctx.fillText(scoreNumber, scoreX, 10);
}
/* ================= Move Enemies ================= */
function moveEnemies(){
  enemies.forEach(e=>{
    if(!e.alive) return;
    e.y += e.speedY;
    e.x = e.baseX + Math.sin(e.phase + e.y*e.frequency) * e.amplitude;
    if(e.y > canvas.height + 20) e.alive = false;
  });
}

function enemyShoot(){
  enemies.forEach(e=>{
    if(!e.alive) return;
    if(Math.random() < enemyShootChance){
      enemyBullets.push({
        x: e.x,
        y: e.y + 8,
        speed: enemyBulletSpeed
      });
      playEnemyFireSound();
    }
  });
}

/* ================= Collision ================= */
function checkHits(){
  for(let i = bullets.length-1; i>=0; i--){
    const b = bullets[i];
    for(let e of enemies){
      if(!e.alive) continue;

      const enemyHitbox = {
        left: e.x - 20,
        right: e.x + 20,
        top: e.y - 20,
        bottom: e.y + 20
      };

      if(
        b.x >= enemyHitbox.left &&
        b.x <= enemyHitbox.right &&
        b.y >= enemyHitbox.top &&
        b.y <= enemyHitbox.bottom
      ){
        e.alive = false;
        bullets.splice(i, 1);
        spawnExplosion(e.x, e.y);
        score += 10;
        break;
      }
    }
  }
}

function checkEnemyHits() {
  
  const shipHitbox = {
    left: ship.x - 17,
    right: ship.x + 17,
    top: ship.y - 18,    
    bottom: ship.y + 18  
  };

  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    const b = enemyBullets[i];
    const bulletFront = b.y + 12;
    const bulletBack = b.y;

    if (
      !ship.shield &&
      b.x >= shipHitbox.left &&
      b.x <= shipHitbox.right &&
      bulletFront >= shipHitbox.top && 
      bulletBack <= shipHitbox.bottom
    ) {
      enemyBullets.splice(i, 1);
      processPlayerDeath();
      return;
    }
  }

  // CHECK ENEMY BALLOONS HITTING PLAYER
  enemies.forEach(e => {
    if (!e.alive) return;

    const dist = Math.hypot(ship.x - e.x, ship.y - e.y);
    
    if (!ship.shield && dist < 35) {
      e.alive = false;
      spawnExplosion(e.x, e.y); 
      processPlayerDeath();
    }
  });
}

function processPlayerDeath() {
  lives--;
  spawnExplosion(ship.x, ship.y, true);

  if (lives <= 0) {
    gameOver = true;
    setTimeout(() => {
      alert("GAME OVER\nScore: " + score + "\nWave: " + wave);
      location.reload(); 
    }, 100);
  } else {
    spawnPlayer(); 
  }
}


/* ================= Player Respawn ================= */
function spawnPlayer(){
  const ui = document.getElementById("ui");
  ship.x = canvas.width / 2;
  ship.y = canvas.height - 30 - ui.offsetHeight - 100;
  ship.shield = true;
  setTimeout(()=>{ ship.shield = false; }, 3000);
}

/* ================= Waves ================= */
function isWaveCleared(){
  return enemies.every(e=>!e.alive);
}
function increaseDifficulty() {
  wave++;
  hpIconSpawnedThisWave = false;

  // stronger difficulty growth per wave
  enemyBaseSpeed = Math.min(0.3 + Math.pow(wave, 0.3) * 0.125, maxEnemySpeed);
  enemyBulletSpeed = Math.min(2 + Math.pow(wave, 0.25) * 0.08, 6); 
  enemyShootChance = Math.min(0.0002 + Math.pow(wave, 0.3) * 0.0003, maxShootChance); 

  spawnWave();
}


/* ================= Game Loop ================= */
function update(){
  if(gameOver) return;

  if (wave % 5 === 0 && ! hpIconSpawnedThisWave) {
    spawnHPIcon();
    hpIconSpawnedThisWave = true;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawStars();

  if(keys.up) ship.y -= 4;
  if(keys.down) ship.y += 4;
  if(keys.left) ship.x -= 4;
  if(keys.right) ship.x += 4;

  const ui = document.getElementById("ui");
  const bottomLimit = canvas.height - 30 - ui.offsetHeight - 200;
  ship.x = Math.max(12, Math.min(canvas.width - 12, ship.x));
  ship.y = Math.max(30, Math.min(bottomLimit, ship.y));

  moveEnemies();
  enemyShoot();
  drawShip();
  drawBullets();
  drawEnemies();
  drawItems();
  drawExplosions();
  drawEnemyBullets();
  drawUI();
  checkHits();
  checkEnemyHits();

  if(isWaveCleared()) increaseDifficulty();
  requestAnimationFrame(update);
}

/* ================= D-Pad ================= */
const activeTouches = {};
const dpad = document.getElementById("dpad");

function handleDpadTouches(e){
  e.preventDefault();
  keys.up = keys.down = keys.left = keys.right = false;
  document.querySelectorAll("#dpad .arcade-btn")
    .forEach(btn=>btn.classList.remove("pressed"));

  const rect = dpad.getBoundingClientRect();
  for(let t of e.touches){
    if(t.target.closest("#dpad")){
      const x = t.clientX - rect.left;
      const y = t.clientY - rect.top;
      const dx = x - rect.width/2;
      const dy = y - rect.height/2;

      if(Math.abs(dx) > Math.abs(dy)){
        if(dx < 0){
          keys.left = true;
          dpad.querySelector(".left").classList.add("pressed");
        } else {
          keys.right = true;
          dpad.querySelector(".right").classList.add("pressed");
        }
      } else {
        if(dy < 0){
          keys.up = true;
          dpad.querySelector(".up").classList.add("pressed");
        } else {
          keys.down = true;
          dpad.querySelector(".down").classList.add("pressed");
        }
      }
      activeTouches[t.identifier] = true;
    }
  }
}

function handleDpadTouchesEnd(e){
  e.preventDefault();
  for(let t of e.changedTouches)
    if(activeTouches[t.identifier])
      delete activeTouches[t.identifier];

  if(Object.keys(activeTouches).length === 0){
    keys.up = keys.down = keys.left = keys.right = false;
    document.querySelectorAll("#dpad .arcade-btn")
      .forEach(btn=>btn.classList.remove("pressed"));
  }
}

dpad.addEventListener("touchstart", handleDpadTouches);
dpad.addEventListener("touchmove", handleDpadTouches);
dpad.addEventListener("touchend", handleDpadTouchesEnd);
dpad.addEventListener("touchcancel", handleDpadTouchesEnd);

/* ================= Shoot Button ================= */
const shootBtn = document.getElementById("shoot");
shootBtn.addEventListener("touchstart", e=>{
  e.preventDefault();
  bullets.push({x: ship.x, y: ship.y});
  playGunSound();
  shootBtn.classList.add("pressed");
});
shootBtn.addEventListener("touchend", e=>{
  e.preventDefault();
  shootBtn.classList.remove("pressed");
});

/* ================= Start Game ================= */
spawnWave();
spawnPlayer();
update();
</script>
</body>
</html>